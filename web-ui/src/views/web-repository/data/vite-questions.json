[
  {
    "title": "什么是Vite？它与传统的打包工具有什么区别？",
    "category": "Vite基础",
    "content": "请解释Vite的基本概念、工作原理以及它与Webpack、Rollup等传统打包工具的主要区别。",
    "answer": "Vite是一个现代前端构建工具，它提供了极速的开发服务器和优化的构建输出。\n\n**Vite的核心特点：**\n\n1. **极速的开发服务器**：利用浏览器原生ES模块支持，实现了按需编译，避免了传统打包工具的全部编译等待时间。\n\n2. **优化的构建输出**：使用Rollup进行生产构建，生成高度优化的静态资源。\n\n3. **丰富的功能支持**：内置了模块热替换（HMR）、CSS预处理器支持、TypeScript支持等现代前端开发所需的功能。\n\n**Vite与传统打包工具的主要区别：**\n\n1. **开发模式不同**：\n   - 传统工具（如Webpack）：在开发时会将所有模块打包成一个或多个bundle。\n   - Vite：在开发时利用浏览器的ES模块支持，直接提供原生ES模块，无需打包。\n\n2. **构建速度不同**：\n   - 传统工具：随着项目规模增大，开发服务器启动时间和热更新时间会显著增加。\n   - Vite：由于采用按需编译策略，开发服务器启动速度和热更新速度几乎不受项目规模影响。\n\n3. **处理依赖的方式不同**：\n   - 传统工具：所有依赖都需要打包。\n   - Vite：将依赖分为两类：\n     - 依赖模块（第三方库）：在开发时预构建并缓存，提高性能。\n     - 应用模块：按需编译，支持热更新。\n\nVite的这些特点使其特别适合大型项目的开发，能够显著提高开发效率和开发体验。",
    "code": "// vite.config.js 配置示例\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\n\nexport default defineConfig({\n  // 基础配置\n  base: '/my-app/', // 部署路径前缀\n  mode: 'development', // 模式\n  define: { // 全局常量替换\n    'process.env': process.env\n  },\n  // 插件配置\n  plugins: [vue()],\n  // 服务器配置\n  server: {\n    port: 3000,\n    open: true, // 自动打开浏览器\n    proxy: {\n      '/api': {\n        target: 'http://localhost:8080',\n        changeOrigin: true,\n        rewrite: function(path) { return path.replace(/^\\/api/, ''); }\n      }\n    },\n    // 其他服务器配置\n    cors: true,\n    https: false\n  },\n  // 构建配置\n  build: {\n    outDir: 'dist',\n    assetsDir: 'assets',\n    sourcemap: false,\n    minify: 'terser',\n    rollupOptions: {\n      // Rollup相关配置\n      output: {\n        // 自定义输出文件名\n        chunkFileNames: 'assets/js/[name]-[hash].js',\n        entryFileNames: 'assets/js/[name]-[hash].js',\n        assetFileNames: 'assets/[ext]/[name]-[hash].[ext]'\n      }\n    }\n  },\n  // CSS配置\n  css: {\n    preprocessorOptions: {\n      scss: {\n        additionalData: '@import \"./src/styles/variables.scss\";'\n      }\n    },\n    devSourcemap: true\n  },\n  // 解析配置\n  resolve: {\n    alias: {\n      '@': '/src'\n    },\n    extensions: ['.js', '.vue', '.json']\n  },\n  // 优化配置\n  optimizeDeps: {\n    include: ['axios', 'lodash']\n  }\n})",
    "difficulty": "初级"
  },
  {
    "title": "Vite的插件系统是如何工作的？如何开发一个简单的Vite插件？",
    "category": "插件系统",
    "content": "请解释Vite的插件系统架构，并提供一个简单的插件开发示例。",
    "answer": "Vite的插件系统基于Rollup的插件接口，但添加了一些Vite特有的钩子，使其能够处理开发服务器和构建过程中的各种场景。\n\n**Vite插件系统的主要特点：**\n\n1. **兼容Rollup插件**：大部分Rollup插件可以在Vite中直接使用\n2. **Vite特有钩子**：提供了针对开发服务器的特殊钩子，如configureServer、transformIndexHtml等\n3. **钩子类型**：分为通用钩子（适用于开发和构建）和构建特有钩子\n\n**插件的基本结构：**\n一个Vite插件通常是一个包含name和各种钩子函数的对象。\n\n**开发Vite插件的基本步骤：**\n\n1. 创建插件对象，包含name属性和需要的钩子函数\n2. 实现钩子函数来处理特定的场景\n3. 在vite.config.js中注册插件\n\n**常见的Vite特有的钩子：**\n\n- `configureServer`：用于配置开发服务器\n- `transformIndexHtml`：用于转换HTML入口文件\n- `handleHotUpdate`：用于自定义热模块替换逻辑\n- `config`：用于修改Vite的配置\n\n开发插件时，需要了解插件执行的生命周期和顺序，以便正确实现所需功能。Vite的插件系统非常灵活，可以用于各种场景，如代码转换、资源处理、服务器配置等。",
    "code": "// 一个简单的Vite插件示例\nfunction myPlugin() {\n  return {\n    name: 'my-vite-plugin', // 插件名称，必须唯一\n\n    // 配置开发服务器\n    configureServer: function(server) {\n      console.log('配置开发服务器');\n      // 可以在这里添加中间件\n      server.middlewares.use('/my-plugin', function(req, res, next) {\n        res.end('Hello from my plugin!');\n      });\n    },\n\n    // 转换HTML\n    transformIndexHtml: function(html) {\n      console.log('转换HTML文件');\n      return html.replace('</body>', '<script>console.log(\\'Injected by my plugin\\')</script></body>');\n    },\n\n    // 转换代码\n    transform: function(code, id) {\n      // 只处理.js文件\n      if (id.endsWith('.js')) {\n        console.log('转换文件: ' + id);\n        // 简单示例：在文件末尾添加注释\n        return code + '\n// 此文件已被my-plugin处理';\n      }\n      return null; // 返回null表示不进行转换\n    },\n\n    // 处理热更新\n    handleHotUpdate: function({ file, server }) {\n      console.log('文件发生变化: ' + file);\n      // 可以在这里自定义热更新逻辑\n      // 如果返回null，则使用默认的热更新逻辑\n      return null;\n    }\n  };\n}\n\n// 在vite.config.js中使用插件\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\n\nexport default defineConfig({\n  plugins: [\n    vue(),\n    myPlugin() // 使用自定义插件\n  ]\n})",
    "difficulty": "中级"
  },
  {
    "title": "Vite的环境变量配置和使用方法",
    "category": "环境变量",
    "content": "请详细说明在Vite项目中如何配置和使用环境变量。",
    "answer": "Vite提供了灵活的环境变量配置系统，可以根据不同的环境（如开发环境、生产环境）使用不同的配置。\n\n**环境变量文件：**\nVite使用`.env`文件来存储环境变量，支持以下几种文件：\n\n- `.env`：所有环境都加载的通用配置\n- `.env.local`：所有环境都加载的本地配置，不应该提交到版本控制系统\n- `.env.[mode]`：特定模式的配置，如`.env.development`、`.env.production`\n- `.env.[mode].local`：特定模式的本地配置\n\n**环境变量的命名规则：**\n\n- 只有以`VITE_`开头的变量会被暴露给客户端代码\n- 其他变量仅在配置文件中可用\n\n**在客户端代码中使用环境变量：**\n\n在JavaScript/TypeScript代码中，可以通过`import.meta.env.VITE_变量名`来访问环境变量。\n\n**在配置文件中使用环境变量：**\n\n在`vite.config.js`中，可以通过`process.env.变量名`来访问环境变量。\n\n**环境变量的加载顺序：**\n\n当多个环境变量文件存在时，Vite会按照以下顺序加载，后面的文件会覆盖前面的同名变量：\n\n1. `.env`\n2. `.env.local`\n3. `.env.[mode]`\n4. `.env.[mode].local`\n\n**环境变量的类型转换：**\n\nVite会自动将环境变量的值转换为适当的类型：\n\n- `true`、`false`、`null`会被转换为对应的布尔值或空值\n- 数字字符串会被转换为数字类型\n\n通过合理配置和使用环境变量，可以使应用更容易在不同环境中部署，并保护敏感信息（如API密钥）不被暴露在客户端代码中。",
    "code": "// .env文件示例\nVITE_APP_TITLE=My Vite App\nVITE_API_URL=http://api.example.com\n\n// .env.development文件示例\nVITE_APP_TITLE=My Vite App (Development)\nVITE_API_URL=http://localhost:3000/api\n\n// .env.production文件示例\nVITE_APP_TITLE=My Vite App\nVITE_API_URL=https://api.example.com\nVITE_ENABLE_LOGGING=false\n\n// 在JavaScript代码中使用环境变量\nconsole.log(import.meta.env.VITE_APP_TITLE); // 输出应用标题\nconsole.log(import.meta.env.VITE_API_URL); // 输出API URL\n\n// 使用环境变量配置API请求\nexport const apiClient = {\n  baseUrl: import.meta.env.VITE_API_URL,\n  \n  fetchData: async function(endpoint) {\n    const response = await fetch(this.baseUrl + '/' + endpoint);\n    return response.json();\n  }\n};\n\n// 在vite.config.js中使用环境变量\nimport { defineConfig, loadEnv } from 'vite'\nimport vue from '@vitejs/plugin-vue'\n\nexport default defineConfig(function({ mode }) {\n  // 加载环境变量，第二个参数是环境变量文件的目录\n  const env = loadEnv(mode, process.cwd(), '')\n  \n  return {\n    plugins: [vue()],\n    server: {\n      port: Number(env.VITE_SERVER_PORT) || 3000,\n      open: env.VITE_OPEN_BROWSER === 'true'\n    },\n    build: {\n      outDir: env.VITE_BUILD_DIR || 'dist'\n    }\n  }\n})",
    "difficulty": "初级"
  },
  {
    "title": "Vite中的静态资源处理方式",
    "category": "静态资源",
    "content": "请解释Vite如何处理不同类型的静态资源。",
    "answer": "Vite提供了强大的静态资源处理能力，支持多种资源类型的导入和优化。\n\n**基本的静态资源处理：**\n\n1. **图片资源**：\n   - 支持导入jpg、png、gif、svg等格式\n   - 小于指定大小的图片会被内联为Data URL\n   - SVG可以作为组件导入（Vue/React）\n\n2. **样式资源**：\n   - 支持CSS、SCSS、LESS等预处理器\n   - 自动处理CSS Modules\n   - 支持PostCSS配置\n\n3. **字体资源**：\n   - 支持导入各种字体文件\n   - 自动处理字体文件的引用路径\n\n4. **JSON文件**：\n   - 支持直接导入JSON文件\n   - 自动转换为JavaScript对象\n\n**特殊的资源导入方式：**\n\n1. **URL导入**：\n   - 使用`?url`后缀可以获取资源的URL\n   - 适用于需要动态加载的资源\n\n2. **内联导入**：\n   - 使用`?inline`后缀可以将资源内联为Data URL\n   - 适用于小体积的资源\n\n3. **原始导入**：\n   - 使用`?raw`后缀可以获取资源的原始内容\n   - 适用于需要处理文件内容的场景\n\n**生产构建时的优化：**\n\n- 图片压缩和优化\n- 资源文件名添加哈希，实现长效缓存\n- 代码分割，按需加载\n- 字体文件优化\n\nVite的静态资源处理机制使开发者可以像导入JavaScript模块一样导入各种静态资源，大大简化了资源管理和引用的复杂性。",
    "code": "// 导入图片资源\nimport logo from './assets/logo.png';\nimport iconSvg from './assets/icon.svg';\n\n// 使用图片\nconst img = document.createElement('img');\nimg.src = logo;\ndocument.body.appendChild(img);\n\n// 获取资源的URL\nimport backgroundUrl from './assets/background.jpg?url';\nelement.style.backgroundImage = 'url(' + backgroundUrl + ')';\n\n// 内联资源\nimport smallIcon from './assets/small-icon.png?inline';\n// smallIcon 会被转换为 Data URL\n\n// 获取原始内容\nimport shaderSource from './shaders/vertex.glsl?raw';\n// shaderSource 是文件的原始文本内容\n\n// 在Vue组件中使用SVG作为组件\nimport { defineComponent } from 'vue';\nimport IconComponent from './assets/icon.svg';\n\nexport default defineComponent({\n  components: {\n    IconComponent\n  },\n  template: '<div>\n    <IconComponent />\n  </div>'\n});\n\n// 在CSS中引用资源\n.image-container {\n  background-image: url('./assets/pattern.jpg');\n  /* Vite会自动处理这个URL */\n}\n\n// vite.config.js中的资源配置\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  assetsInclude: ['**/*.gltf', '**/*.glb'], // 添加额外的资源类型\n  build: {\n    rollupOptions: {\n      output: {\n        assetFileNames: 'assets/[ext]/[name]-[hash].[ext]'\n      }\n    }\n  }\n})",
    "difficulty": "初级"
  }
]