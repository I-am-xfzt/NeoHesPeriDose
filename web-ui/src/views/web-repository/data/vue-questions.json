[
  {
    "title": "Vue 3 相比 Vue 2 有哪些主要变化？",
    "category": "Vue3新特性",
    "content": "请简述Vue 3相比Vue 2的主要改进和新特性。",
    "answer": "Vue 3相比Vue 2的主要变化包括：\n\n1. **性能提升**\n   - 更小的打包体积（约减少41%）\n   - 虚拟DOM重写，渲染速度提升55%\n   - 静态提升，减少不必要的更新\n   - 优化了响应式系统\n\n2. **组合式API（Composition API）**\n   - 提供了setup函数作为组件的入口点\n   - 更灵活的逻辑复用和组合方式\n   - 更好的TypeScript支持\n   - 函数式编程风格\n\n3. **响应式系统重构**\n   - 使用Proxy代替Object.defineProperty\n   - 支持监听数组索引和对象新增属性\n   - 更好的性能和更全面的响应式能力\n\n4. **Teleport组件**\n   - 允许将组件内容渲染到DOM中的任意位置\n   - 适用于模态框、弹出菜单等场景\n\n5. **Fragments**\n   - 支持组件返回多个根元素\n   - 不需要额外的包裹元素\n\n6. **更强大的TypeScript支持**\n   - 整个框架用TypeScript重写\n   - 更好的类型推断和IDE支持\n\n7. **自定义渲染器API**\n   - 更容易创建自定义渲染器\n   - 适用于跨平台开发\n\nVue 3在保持Vue 2易用性的同时，提供了更强大的性能和更灵活的开发方式。",
    "code": "// Vue 3 组合式API示例\nimport { ref, computed, onMounted } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    const doubleCount = computed(() => count.value * 2)\n    \n    const increment = () => {\n      count.value++\n    }\n    \n    onMounted(() => {\n      console.log('组件已挂载')\n    })\n    \n    return {\n      count,\n      doubleCount,\n      increment\n    }\n  }\n}",
    "difficulty": "中级"
  },
  {
    "title": "Vue中的computed和watch有什么区别？",
    "category": "响应式系统",
    "content": "请解释computed和watch的区别及使用场景。",
    "answer": "**computed (计算属性)**\n- **定义**：基于响应式依赖进行缓存的计算值\n- **缓存性**：只有在依赖发生变化时才会重新计算\n- **使用场景**：需要根据其他数据派生新值的场景\n- **写法**：声明式，返回计算结果\n\n**watch (监听器)**\n- **定义**：监听响应式数据的变化并执行副作用\n- **缓存性**：每次数据变化都会执行回调\n- **使用场景**：需要在数据变化时执行异步或开销较大的操作\n- **写法**：命令式，执行函数逻辑\n\n**主要区别**\n1. computed专注于计算值，watch专注于执行副作用\n2. computed有缓存机制，watch没有\n3. computed不能执行异步操作，watch可以\n4. computed适合简单的派生值，watch适合复杂的副作用逻辑\n\n**使用建议**\n- 当需要从现有数据派生新值时，使用computed\n- 当需要在数据变化时执行异步操作、API调用、复杂计算等时，使用watch",
    "code": "// computed示例\nconst count = ref(0)\nconst doubleCount = computed(() => count.value * 2)\n\n// watch示例\nwatch(count, (newValue, oldValue) => {\n  console.log(`count从${oldValue}变为${newValue}`)\n  // 可以在这里执行异步操作\n  fetch('/api/update', {\n    method: 'POST',\n    body: JSON.stringify({ count: newValue })\n  })\n})",
    "difficulty": "初级"
  },
  {
    "title": "Vue组件间通信的方式有哪些？",
    "category": "组件通信",
    "content": "请列举Vue中常用的组件间通信方式及其适用场景。",
    "answer": "Vue中常用的组件间通信方式包括：\n\n1. **props / emit**\n   - **使用场景**：父子组件间通信\n   - **特点**：父组件通过props向子组件传递数据，子组件通过emit向父组件发送事件\n   - **Vue 3**：支持defineProps和defineEmits宏\n\n2. **事件总线（Event Bus）**\n   - **使用场景**：任意组件间通信，特别是跨层级组件\n   - **特点**：通过一个全局事件中心进行通信\n   - **Vue 3**：推荐使用mitt等第三方库\n\n3. **provide / inject**\n   - **使用场景**：祖先组件向后代组件传递数据，跨层级通信\n   - **特点**：provide提供数据，inject注入数据\n   - **Vue 3**：支持响应式数据传递\n\n4. **Vuex/Pinia**\n   - **使用场景**：大型应用的状态管理，多组件共享状态\n   - **特点**：集中式存储管理，提供状态变更的规则\n   - **Vue 3**：推荐使用Pinia\n\n5. **ref / $parent**\n   - **使用场景**：父子组件直接访问\n   - **特点**：通过ref访问子组件实例，通过$parent访问父组件实例\n   - **注意**：过度使用会增加组件耦合度\n\n6. **slot（插槽）**\n   - **使用场景**：父组件向子组件传递内容\n   - **类型**：默认插槽、具名插槽、作用域插槽\n   - **特点**：更灵活的内容分发\n\n选择合适的通信方式取决于组件的层级关系、数据复杂度以及项目规模等因素。",
    "code": "// props / emit 示例（Vue 3）\n// 父组件\n<script setup>\nimport Child from './Child.vue'\nconst message = ref('Hello from parent')\nconst handleUpdate = (newValue) => {\n  console.log('Received:', newValue)\n};\n</script>\n\n<template>\n  <Child :message=\"message\" @update=\"handleUpdate\" />\n</template>\n\n// 子组件\n<script setup>\nconst props = defineProps(['message']);\nconst emit = defineEmits(['update']);\n\nconst sendUpdate = () => {\n  emit('update', 'Hello from child')\n};\n</script>\n\n<template>\n  <p>{{ message }}</p>\n  <button @click=\"sendUpdate\">发送更新</button>\n</template>",
    "difficulty": "中级"
  },
  {
    "title": "什么是Vue的生命周期？有哪些钩子函数？",
    "category": "生命周期",
    "content": "请解释Vue组件的生命周期概念及主要钩子函数。",
    "answer": "**Vue的生命周期**是指组件从创建到销毁的一系列过程，Vue提供了一系列钩子函数，允许开发者在不同阶段执行特定的操作。\n\n**主要生命周期阶段**\n1. **创建阶段**\n   - beforeCreate：实例刚被创建，数据观测和事件配置尚未完成\n   - created：实例已创建完成，可访问数据、计算属性等，但DOM尚未生成\n\n2. **挂载阶段**\n   - beforeMount：模板编译完成，但尚未挂载到DOM\n   - mounted：组件已挂载到DOM，可以进行DOM操作\n\n3. **更新阶段**\n   - beforeUpdate：数据更新时触发，发生在虚拟DOM重新渲染之前\n   - updated：组件已更新，DOM已重新渲染\n\n4. **卸载阶段**\n   - beforeUnmount：组件卸载前触发\n   - unmounted：组件已卸载，可清理定时器、事件监听器等\n\n**Vue 3特有的生命周期钩子**\n- onRenderTracked：跟踪响应式依赖时触发\n- onRenderTriggered：响应式依赖变更并触发渲染时触发\n\n**使用场景**\n- created：初始化数据、发起网络请求\n- mounted：DOM操作、初始化第三方库\n- beforeUnmount：清理资源、移除事件监听\n\n生命周期钩子函数使开发者能够在组件的不同阶段执行特定的逻辑，是Vue组件开发的重要组成部分。",
    "code": "// Vue 3 生命周期钩子示例\nimport { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted } from 'vue'\n\nexport default {\n  setup() {\n    onBeforeMount(() => {\n      console.log('组件即将挂载')\n    })\n    \n    onMounted(() => {\n      console.log('组件已挂载')\n      // 可以在这里进行DOM操作\n      document.getElementById('app').classList.add('loaded')\n    })\n    \n    onBeforeUpdate(() => {\n      console.log('组件即将更新')\n    })\n    \n    onUpdated(() => {\n      console.log('组件已更新')\n    })\n    \n    onBeforeUnmount(() => {\n      console.log('组件即将卸载')\n      // 清理资源\n      clearInterval(timer.value)\n    })\n    \n    onUnmounted(() => {\n      console.log('组件已卸载')\n    })\n    \n    const timer = ref(null)\n    \n    return {\n      timer\n    }\n  }\n}",
    "difficulty": "初级"
  },
  {
    "title": "Vue中的v-model是什么？如何自定义v-model？",
    "category": "模板语法",
    "content": "请解释v-model指令的工作原理以及如何为自定义组件实现v-model。",
    "answer": "**v-model**是Vue提供的用于实现表单元素和组件数据双向绑定的指令。\n\n**基本工作原理**\n- 对于表单元素，v-model是语法糖，它会根据元素类型自动选择正确的方式来更新元素\n- 例如，对于input[type='text']，v-model相当于绑定value属性和input事件\n\n**v-model的默认行为**\n- 在组件上使用时，v-model默认会：\n  1. 将value作为prop传入\n  2. 监听input事件，并将事件参数作为新值\n\n**自定义v-model**\n在Vue 3中，可以通过以下方式自定义组件的v-model：\n1. 使用modelValue作为prop名\n2. 使用update:modelValue作为事件名\n3. 可以通过model选项自定义prop和event名称\n\n**使用场景**\n- 创建可复用的表单组件\n- 实现复杂的表单交互\n- 封装第三方UI库的表单控件\n\n自定义v-model使组件的使用更加直观和符合Vue的设计理念，提高了代码的可读性和可维护性。",
    "code": "// 自定义v-model组件示例\n// MyInput.vue\n<script setup>\nconst props = defineProps(['modelValue'])\nconst emit = defineEmits(['update:modelValue'])\n\nconst handleInput = (event) => {\n  emit('update:modelValue', event.target.value)\n}\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"modelValue\"\n    @input=\"handleInput\"\n    placeholder=\"请输入内容\"\n  />\n</template>\n\n// 使用自定义组件\n<script setup>\nimport { ref } from 'vue'\nimport MyInput from './MyInput.vue'\n\nconst message = ref('Hello')\n</script>\n\n<template>\n  <p>输入的内容: {{ message }}</p>\n  <MyInput v-model=\"message\" />\n  \n  <!-- 等同于 -->\n  <!-- <MyInput :modelValue=\"message\" @update:modelValue=\"message = $event\" /> -->\n</template>",
    "difficulty": "中级"
  },
  {
    "title": "Vue中的虚拟DOM是什么？有什么作用？",
    "category": "Vue原理",
    "content": "请解释虚拟DOM的概念、工作原理以及在Vue中的作用。",
    "answer": "**虚拟DOM（Virtual DOM）**是对真实DOM的一种轻量级抽象表示，是由JavaScript对象构成的树状结构，包含了真实DOM的结构和属性信息。\n\n**工作原理**\n1. **创建虚拟DOM**：当组件状态变化时，Vue会创建一个新的虚拟DOM树\n2. **Diff算法**：Vue会对比新旧虚拟DOM树的差异（diffing）\n3. **更新真实DOM**：只将差异部分（最小化更新）应用到真实DOM上\n\n**Vue中的虚拟DOM特点**\n- Vue 2使用Snabbdom库的启发实现了虚拟DOM\n- Vue 3对虚拟DOM进行了重写，引入了静态提升、补丁标记等优化\n- 虚拟DOM在Vue的渲染过程中扮演着核心角色\n\n**作用和优势**\n1. **提升性能**：\n   - 减少直接操作真实DOM的次数\n   - 批量更新DOM，减少浏览器重排和重绘\n   - 只更新必要的DOM节点\n\n2. **跨平台**：\n   - 虚拟DOM使Vue能够渲染到不同平台（浏览器、服务器、移动设备等）\n   - 不同平台可以提供各自的渲染器实现\n\n3. **抽象层**：\n   - 为开发者提供了声明式的UI描述方式\n   - 开发者无需直接操作DOM，专注于业务逻辑\n\n4. **组件化**：\n   - 虚拟DOM是Vue组件化的基础\n   - 支持组件的组合和复用\n\n虽然虚拟DOM有一定的性能开销，但对于大多数应用场景，它带来的开发效率和性能优化远大于其开销。",
    "difficulty": "高级"
  },
  {
    "title": "Vue 3中的Composition API和Options API有什么区别？",
    "category": "Vue3新特性",
    "content": "请比较Vue 3中的Composition API和传统的Options API的区别及适用场景。",
    "answer": "**Options API**和**Composition API**是Vue中两种不同的组件编写方式。\n\n**Options API**\n- **特点**：通过选项（如data、methods、computed等）组织组件逻辑\n- **优势**：\n  - 简单直观，容易上手\n  - 结构清晰，对于小型组件很友好\n  - 学习曲线平缓\n- **劣势**：\n  - 逻辑关注点分散，大型组件难以维护\n  - 相同逻辑无法跨组件复用（mixins有命名冲突等问题）\n  - TypeScript支持有限\n\n**Composition API**\n- **特点**：通过函数组合的方式组织组件逻辑\n- **优势**：\n  - 逻辑关注点聚合，大型组件更容易维护\n  - 更好的逻辑复用（通过组合函数）\n  - 更强大的TypeScript支持\n  - 树摇友好，未使用的代码可以被排除\n  - 更灵活的代码组织方式\n- **劣势**：\n  - 学习曲线较陡峭\n  - 对于简单组件可能显得冗余\n\n**主要区别**\n1. **代码组织方式**：Options API按选项分类，Composition API按逻辑关注点分类\n2. **逻辑复用**：Composition API提供了更优雅的逻辑复用方式\n3. **类型支持**：Composition API对TypeScript的支持更完善\n4. **性能优化**：Composition API更有利于树摇和代码优化\n\n**适用场景**\n- **Options API**：小型组件、快速开发、团队对Vue 2更熟悉\n- **Composition API**：大型组件、复杂逻辑、需要更好的TypeScript支持、需要逻辑复用\n\nVue 3同时支持两种API风格，开发者可以根据项目需求和团队熟悉度选择合适的方式。",
    "code": "// Options API 示例\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  computed: {\n    doubleCount() {\n      return this.count * 2\n    }\n  },\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n  mounted() {\n    console.log('Component mounted')\n  }\n}\n\n// Composition API 示例\nimport { ref, computed, onMounted } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    const doubleCount = computed(() => count.value * 2)\n    \n    const increment = () => {\n      count.value++\n    }\n    \n    onMounted(() => {\n      console.log('Component mounted')\n    })\n    \n    return {\n      count,\n      doubleCount,\n      increment\n    }\n  }\n}",
    "difficulty": "中级"
  }
]