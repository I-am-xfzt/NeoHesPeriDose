[
  {
    "title": "TypeScript 与 JavaScript 的区别是什么？",
    "category": "基础类型",
    "content": "请简述 TypeScript 相比 JavaScript 的主要优势和区别。",
    "answer": "TypeScript 是 JavaScript 的超集，添加了静态类型系统和更多的语言特性。主要区别和优势包括：\n\n1. **类型系统**\n   - TypeScript 提供静态类型检查，可以在编译时捕获类型错误\n   - JavaScript 是动态类型语言，错误通常在运行时才会发现\n\n2. **开发体验**\n   - TypeScript 提供更好的代码提示和自动补全\n   - 编辑器能够提供更准确的错误提示和重构支持\n\n3. **代码可维护性**\n   - 类型注解使代码更具自文档性\n   - 大型项目更容易理解和维护\n   - 重构更安全\n\n4. **额外的语言特性**\n   - 接口 (Interfaces)\n   - 泛型 (Generics)\n   - 枚举 (Enums)\n   - 联合类型和交叉类型\n   - 装饰器\n   - 抽象类\n\n5. **编译过程**\n   - TypeScript 需要编译成 JavaScript 才能在浏览器中运行\n   - 编译过程可以检测类型错误\n\n6. **生态系统**\n   - TypeScript 兼容所有 JavaScript 库和框架\n   - 许多现代框架（如 Vue 3、Angular）使用 TypeScript 开发或提供良好支持\n\nTypeScript 的核心价值在于通过静态类型检查提高代码质量和开发效率，特别适合大型团队和复杂项目。",
    "code": "// JavaScript 代码\nfunction add(a, b) {\n  return a + b;\n}\n\n// 可能的错误用法\nadd('1', 2); // 返回 '12' 而不是预期的 3\n\n// TypeScript 代码\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// 编译时错误\n// add('1', 2); // 类型 '\"1\"' 的参数不能赋给类型 'number' 的参数",
    "difficulty": "初级"
  },
  {
    "title": "TypeScript 中的基本类型有哪些？",
    "category": "基础类型",
    "content": "请列举 TypeScript 中的基本数据类型。",
    "answer": "TypeScript 中的基本类型包括：\n\n1. **原始类型**\n   - `number`：数字类型（包括整数和浮点数）\n   - `string`：字符串类型\n   - `boolean`：布尔类型（true/false）\n   - `null`：表示空值\n   - `undefined`：表示未定义的值\n   - `symbol`：唯一标识符类型（ES6 引入）\n   - `bigint`：大整数类型\n\n2. **对象类型**\n   - `object`：表示非原始类型\n   - 数组类型：`number[]` 或 `Array<number>`\n   - 元组类型：`[string, number]`\n   - 枚举类型：`enum Color { Red, Green, Blue }`\n   - 接口类型：`interface Person { name: string; age: number }`\n   - 类类型：`class Animal { ... }`\n\n3. **特殊类型**\n   - `any`：任意类型，关闭类型检查\n   - `unknown`：未知类型，比 any 更安全\n   - `never`：表示永远不会发生的值的类型\n   - `void`：表示没有返回值的函数\n\n这些类型可以组合使用，形成更复杂的类型，如联合类型、交叉类型等。TypeScript 的类型系统是其核心特性之一，提供了强大的静态类型检查能力。",
    "code": "// 基本类型示例\nconst age: number = 30;\nconst name: string = 'John';\nconst isActive: boolean = true;\nconst nothing: null = null;\nconst notDefined: undefined = undefined;\nconst uniqueId: symbol = Symbol('id');\nconst largeNumber: bigint = BigInt(9007199254740991);\n\n// 数组类型\nconst numbers: number[] = [1, 2, 3];\nconst strings: Array<string> = ['a', 'b', 'c'];\n\n// 元组类型\nconst person: [string, number] = ['John', 30];\n\n// 枚举类型\nenum Direction {\n  Up,\n  Down,\n  Left,\n  Right\n}\n\n// 特殊类型\nconst anyValue: any = 'anything';\nconst unknownValue: unknown = 'unknown';\nconst neverValue: never = (() => { throw new Error('Never returns'); })();\nconst noReturn: void = console.log('Hello');",
    "difficulty": "初级"
  },
  {
    "title": "TypeScript 中的接口和类型别名有什么区别？",
    "category": "接口和类型",
    "content": "请解释 TypeScript 中 interface 和 type 的区别，并给出使用建议。",
    "answer": "在 TypeScript 中，`interface` 和 `type` 都用于定义类型，但它们之间存在一些重要区别：\n\n**接口 (Interface)**\n- 只能用于定义对象类型\n- 可以被合并（多个同名接口会自动合并）\n- 可以被类实现\n- 可以被继承\n- 可以定义函数类型\n\n**类型别名 (Type)**\n- 可以定义任何类型（原始类型、联合类型、交叉类型等）\n- 不能被合并\n- 不能被类实现（除非是对象类型）\n- 可以使用计算属性\n- 可以创建映射类型\n\n**主要区别**\n1. **扩展方式**\n   - 接口使用 `extends` 关键字扩展\n   - 类型别名使用交叉类型 `&` 扩展\n\n2. **声明合并**\n   - 接口支持声明合并\n   - 类型别名不支持声明合并\n\n3. **使用场景**\n   - 接口更适合定义对象的形状，特别是在面向对象编程中\n   - 类型别名更适合定义联合类型、交叉类型等复杂类型\n\n**使用建议**\n- 对于对象结构的定义，优先使用 `interface`\n- 对于需要组合多种类型的情况，使用 `type`\n- 当需要声明合并或被类实现时，必须使用 `interface`\n- 当需要定义映射类型或计算属性时，使用 `type`\n\n在许多情况下，`interface` 和 `type` 可以互换使用，但了解它们的区别有助于做出更合适的选择。",
    "code": "// 接口示例\ninterface Person {\n  name: string;\n  age: number;\n}\n\n// 接口扩展\ninterface Employee extends Person {\n  employeeId: number;\n}\n\n// 接口可以定义函数类型\ninterface Greeting {\n  (name: string): string;\n}\n\n// 类型别名示例\ntype Point = {\n  x: number;\n  y: number;\n};\n\n// 类型别名可以定义联合类型\ntype Status = 'active' | 'inactive' | 'pending';\n\n// 类型别名可以定义交叉类型\ntype AdminUser = Person & {\n  role: 'admin';\n};\n\n// 类型别名可以定义映射类型\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};",
    "difficulty": "中级"
  },
  {
    "title": "什么是泛型？泛型有什么作用？",
    "category": "泛型",
    "content": "请解释 TypeScript 中泛型的概念、语法和使用场景。",
    "answer": "**泛型 (Generics)** 是 TypeScript 中一种创建可重用代码组件的机制，它允许在定义函数、接口或类时不指定具体的类型，而是在使用时再指定类型。\n\n**泛型的作用：**\n1. **代码复用**：创建可以处理多种类型的组件\n2. **类型安全**：在编译时提供类型检查，避免运行时错误\n3. **灵活性**：在保持类型安全的同时，提供灵活的API设计\n\n**泛型的语法：**\n- 使用尖括号 `<T>` 定义类型参数\n- 可以有多个类型参数：`<T, U, V>`\n- 可以指定类型约束：`<T extends SomeType>`\n\n**泛型的使用场景：**\n1. **函数泛型**：创建可以处理不同类型参数的函数\n2. **接口泛型**：定义具有通用属性的接口\n3. **类泛型**：创建可以处理多种类型的类\n4. **类型别名泛型**：定义通用的类型别名\n\n泛型是 TypeScript 中非常强大的特性，它允许开发者编写灵活且类型安全的代码，避免了使用 `any` 类型带来的安全隐患。",
    "code": "// 泛型函数示例\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\n// 使用泛型函数\nconst result1 = identity<string>('hello'); // 显式指定类型\nconst result2 = identity(42); // 类型推断\n\n// 泛型接口示例\ninterface Box<T> {\n  value: T;\n  getValue(): T;\n}\n\nconst stringBox: Box<string> = {\n  value: 'hello',\n  getValue() { return this.value; }\n};\n\n// 泛型类示例\nclass Stack<T> {\n  private items: T[] = [];\n  \n  push(item: T): void {\n    this.items.push(item);\n  }\n  \n  pop(): T | undefined {\n    return this.items.pop();\n  }\n}\n\nconst numberStack = new Stack<number>();\nnumberStack.push(1);\nnumberStack.push(2);\n\n// 泛型约束示例\ninterface Lengthwise {\n  length: number;\n}\n\nfunction logLength<T extends Lengthwise>(arg: T): void {\n  console.log(arg.length);\n}\n\nlogLength('hello'); // 5\nlogLength([1, 2, 3]); // 3",
    "difficulty": "中级"
  },
  {
    "title": "TypeScript 中的类型守卫是什么？如何实现？",
    "category": "类型操作",
    "content": "请解释类型守卫的概念和常见实现方式。",
    "answer": "**类型守卫 (Type Guards)** 是 TypeScript 中一种在特定作用域内缩小变量类型范围的机制，它允许在运行时检查类型，从而在编译时获得更精确的类型推断。\n\n**常见的类型守卫实现方式：**\n\n1. **typeof 类型守卫**\n   - 用于检查基本类型（string、number、boolean、symbol）\n   - 语法：`typeof variable === \"typeName\"`\n\n2. **instanceof 类型守卫**\n   - 用于检查对象是否是某个类的实例\n   - 语法：`variable instanceof ClassName`\n\n3. **in 操作符类型守卫**\n   - 用于检查对象是否具有某个属性\n   - 语法：`propertyName in variable`\n\n4. **自定义类型守卫函数**\n   - 通过返回 `variable is Type` 类型谓词的函数来定义\n   - 语法：`function isType(variable: any): variable is Type { ... }`\n\n5. **字面量类型守卫**\n   - 用于检查联合类型中的字面量类型\n   - 语法：`variable === \"literalValue\"`\n\n类型守卫可以帮助开发者编写更类型安全的代码，减少运行时错误，并提供更好的开发体验。在处理联合类型和可能为 null 或 undefined 的值时特别有用。",
    "code": "// typeof 类型守卫\nfunction processValue(value: string | number) {\n  if (typeof value === 'string') {\n    // 在这个作用域内，value 被推断为 string 类型\n    return value.toUpperCase();\n  } else {\n    // 在这个作用域内，value 被推断为 number 类型\n    return value.toFixed(2);\n  }\n}\n\n// instanceof 类型守卫\nclass Dog {\n  bark() { return 'Woof!'; }\n}\n\nclass Cat {\n  meow() { return 'Meow!'; }\n}\n\nfunction animalSound(animal: Dog | Cat) {\n  if (animal instanceof Dog) {\n    // 在这个作用域内，animal 被推断为 Dog 类型\n    return animal.bark();\n  } else {\n    // 在这个作用域内，animal 被推断为 Cat 类型\n    return animal.meow();\n  }\n}\n\n// in 操作符类型守卫\ninterface Bird {\n  fly: () => void;\n}\n\ninterface Fish {\n  swim: () => void;\n}\n\nfunction move(animal: Bird | Fish) {\n  if ('fly' in animal) {\n    // 在这个作用域内，animal 被推断为 Bird 类型\n    animal.fly();\n  } else {\n    // 在这个作用域内，animal 被推断为 Fish 类型\n    animal.swim();\n  }\n}\n\n// 自定义类型守卫函数\nfunction isStringArray(value: any): value is string[] {\n  return Array.isArray(value) && value.every(item => typeof item === 'string');\n}\n\nfunction processArray(arr: any) {\n  if (isStringArray(arr)) {\n    // 在这个作用域内，arr 被推断为 string[] 类型\n    return arr.map(s => s.toUpperCase());\n  }\n}\n\n// 字面量类型守卫\ntype Shape = 'circle' | 'square' | 'triangle';\n\nfunction getArea(shape: Shape, params: any) {\n  if (shape === 'circle') {\n    return Math.PI * params.radius ** 2;\n  } else if (shape === 'square') {\n    return params.sideLength ** 2;\n  } else if (shape === 'triangle') {\n    return (params.base * params.height) / 2;\n  }\n}",
    "difficulty": "中级"
  },
  {
    "title": "TypeScript 中的装饰器是什么？有哪些类型的装饰器？",
    "category": "高级特性",
    "content": "请解释装饰器的概念、用法和常见类型。",
    "answer": "**装饰器 (Decorators)** 是 TypeScript 中的一种特殊声明，它可以附加到类声明、方法、属性或参数上，以修改类的行为。装饰器本质上是一个函数，它接收被装饰的目标作为参数。\n\n**装饰器的类型：**\n\n1. **类装饰器**\n   - 应用于类声明\n   - 参数是类的构造函数\n   - 可以用来修改类的行为或添加静态属性/方法\n\n2. **方法装饰器**\n   - 应用于类的方法\n   - 参数是目标对象、属性名和属性描述符\n   - 可以用来修改方法的行为、添加日志、性能监控等\n\n3. **属性装饰器**\n   - 应用于类的属性\n   - 参数是目标对象和属性名\n   - 可以用来修改属性的行为或添加元数据\n\n4. **参数装饰器**\n   - 应用于方法的参数\n   - 参数是目标对象、方法名和参数索引\n   - 通常用于添加元数据\n\n5. **访问器装饰器**\n   - 应用于类的 getter/setter 方法\n   - 参数与方法装饰器类似\n\n**装饰器的使用场景：**\n- 日志记录\n- 性能监控\n- 权限控制\n- 依赖注入\n- 序列化/反序列化\n- 自动绑定\n\n需要注意的是，装饰器目前仍是 JavaScript 的提案（Stage 3），在 TypeScript 中使用装饰器需要在 tsconfig.json 中启用 experimentalDecorators 选项。",
    "code": "// 启用装饰器需要在 tsconfig.json 中设置\n// { \"compilerOptions\": { \"experimentalDecorators\": true } }\n\n// 1. 类装饰器\nfunction logClass(target: Function) {\n  // 保存原始构造函数\n  const original = target;\n  \n  // 创建新的构造函数\n  function construct(constructor: any, args: any[]) {\n    const instance = new constructor(...args);\n    console.log(`创建了 ${constructor.name} 的实例`);\n    return instance;\n  }\n  \n  // 代理构造函数\n  const newConstructor: any = function(...args: any[]) {\n    return construct(original, args);\n  };\n  \n  // 保持原型链\n  newConstructor.prototype = original.prototype;\n  \n  return newConstructor;\n}\n\n@logClass\nclass Person {\n  constructor(public name: string, public age: number) {}\n}\n\n// 2. 方法装饰器\nfunction logMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n  \n  descriptor.value = function(...args: any[]) {\n    console.log(`调用方法 ${propertyKey}，参数:`, args);\n    const result = originalMethod.apply(this, args);\n    console.log(`方法 ${propertyKey} 返回:`, result);\n    return result;\n  };\n  \n  return descriptor;\n}\n\nclass Calculator {\n  @logMethod\n  add(a: number, b: number): number {\n    return a + b;\n  }\n}\n\n// 3. 属性装饰器\nfunction logProperty(target: any, propertyKey: string) {\n  let value: any;\n  \n  const getter = function() {\n    console.log(`获取属性 ${propertyKey} 的值:`, value);\n    return value;\n  };\n  \n  const setter = function(newValue: any) {\n    console.log(`设置属性 ${propertyKey} 的值:`, newValue);\n    value = newValue;\n  };\n  \n  Object.defineProperty(target, propertyKey, {\n    get: getter,\n    set: setter,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nclass User {\n  @logProperty\n  public username: string;\n  \n  constructor(username: string) {\n    this.username = username;\n  }\n}\n\n// 4. 参数装饰器\nfunction logParameter(target: any, propertyKey: string, parameterIndex: number) {\n  console.log(`参数装饰器: 方法 ${propertyKey} 的第 ${parameterIndex} 个参数`);\n}\n\nclass Greeter {\n  greet(@logParameter name: string) {\n    return `Hello, ${name}!`;\n  }\n}",
    "difficulty": "高级"
  },
  {
    "title": "TypeScript 中的工具类型有哪些？请举例说明。",
    "category": "工具类型",
    "content": "请列举 TypeScript 中常用的内置工具类型及其用途。",
    "answer": "TypeScript 提供了许多内置的工具类型，用于常见的类型转换。以下是一些常用的工具类型：\n\n1. **Partial<T>**\n   - 将 T 类型的所有属性变为可选\n   - 常用于更新对象的部分属性\n\n2. **Required<T>**\n   - 将 T 类型的所有属性变为必需\n   - 与 Partial<T> 相反\n\n3. **Readonly<T>**\n   - 将 T 类型的所有属性变为只读\n   - 防止对象被修改\n\n4. **Record<K, T>**\n   - 创建一个键类型为 K，值类型为 T 的对象类型\n   - 用于表示具有特定键值对结构的对象\n\n5. **Pick<T, K>**\n   - 从 T 类型中选取指定的属性 K\n   - 用于创建一个只包含部分属性的新类型\n\n6. **Omit<T, K>**\n   - 从 T 类型中排除指定的属性 K\n   - 与 Pick<T, K> 相反\n\n7. **Exclude<T, U>**\n   - 从 T 类型中排除可以赋值给 U 的类型\n   - 用于联合类型\n\n8. **Extract<T, U>**\n   - 从 T 类型中提取可以赋值给 U 的类型\n   - 与 Exclude<T, U> 相反\n\n9. **ReturnType<T>**\n   - 获取函数 T 的返回值类型\n   - 用于类型推断\n\n10. **Parameters<T>**\n    - 获取函数 T 的参数类型组成的元组\n    - 用于类型推断\n\n这些工具类型都是基于 TypeScript 的泛型和条件类型实现的，可以帮助开发者更简洁地定义和操作类型，减少重复代码。",
    "code": "// 定义一个接口\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age?: number;\n}\n\n// 1. Partial<T>\ntype PartialUser = Partial<User>;\n// 等价于 {\n//   id?: number;\n//   name?: string;\n//   email?: string;\n//   age?: number;\n// }\n\n// 2. Required<T>\ntype RequiredUser = Required<User>;\n// 等价于 {\n//   id: number;\n//   name: string;\n//   email: string;\n//   age: number;\n// }\n\n// 3. Readonly<T>\ntype ReadonlyUser = Readonly<User>;\n// 等价于 {\n//   readonly id: number;\n//   readonly name: string;\n//   readonly email: string;\n//   readonly age?: number;\n// }\n\n// 4. Record<K, T>\ntype UserRecord = Record<string, User>;\n// 等价于 { [key: string]: User; }\n\n// 5. Pick<T, K>\ntype UserNameAndEmail = Pick<User, 'name' | 'email'>;\n// 等价于 {\n//   name: string;\n//   email: string;\n// }\n\n// 6. Omit<T, K>\ntype UserWithoutAge = Omit<User, 'age'>;\n// 等价于 {\n//   id: number;\n//   name: string;\n//   email: string;\n// }\n\n// 7. Exclude<T, U>\ntype Primitive = string | number | boolean;\ntype StringOrNumber = Exclude<Primitive, boolean>; // string | number\n\n// 8. Extract<T, U>\ntype PossibleValues = 'a' | 'b' | 'c' | 'd';\ntype SelectedValues = Extract<PossibleValues, 'a' | 'c'>; // 'a' | 'c'\n\n// 9. ReturnType<T>\ntype AddFunction = (a: number, b: number) => number;\ntype AddReturnType = ReturnType<AddFunction>; // number\n\n// 10. Parameters<T>\ntype AddParams = Parameters<AddFunction>; // [a: number, b: number]",
    "difficulty": "中级"
  },
  {
    "title": "TypeScript 中的命名空间和模块有什么区别？",
    "category": "最佳实践",
    "content": "请解释 TypeScript 中命名空间（namespace）和模块（module）的区别及使用场景。",
    "answer": "**命名空间（Namespace）**和**模块（Module）**都是 TypeScript 中用于组织代码的机制，但它们有不同的用途和实现方式。\n\n**命名空间（Namespace）**\n- **定义**：TypeScript 特有的功能，用于将相关的代码组织在一起，并提供命名隔离\n- **语法**：使用 `namespace` 关键字定义\n- **作用域**：可以嵌套，支持跨文件使用（需要使用 `/// <reference path=\"...\" />` 指令）\n- **编译选项**：可以通过 `--outFile` 将多个命名空间编译到一个文件中\n- **使用场景**：组织简单的代码库、避免全局命名冲突、在不使用模块系统的环境中使用\n\n**模块（Module）**\n- **定义**：基于 ES6 模块系统，每个文件是一个独立的模块\n- **语法**：使用 `import` 和 `export` 关键字\n- **作用域**：文件级作用域，模块内的声明默认是私有的\n- **加载机制**：依赖模块加载器（如 CommonJS、AMD、ES modules）\n- **使用场景**：大型项目、需要模块加载器的环境、与第三方库集成\n\n**主要区别**\n1. **标准支持**：模块基于 ES6 标准，命名空间是 TypeScript 特有的\n2. **文件结构**：模块是文件级别的，命名空间可以跨文件\n3. **依赖管理**：模块有明确的导入导出机制，命名空间依赖引用指令\n4. **工具支持**：模块系统有更好的打包工具支持（如 Webpack、Rollup）\n\n**使用建议**\n- 对于现代 JavaScript/TypeScript 项目，优先使用 ES6 模块系统\n- 只有在特定场景（如需要生成单个文件、不使用模块加载器）下才考虑使用命名空间\n- 对于大型项目，结合使用模块和适当的项目结构来组织代码\n\n随着 ES6 模块系统的广泛采用，命名空间的使用场景越来越有限，但在某些特定情况下仍然有用。",
    "code": "// 命名空间示例\nnamespace MathUtilities {\n  export function add(a: number, b: number): number {\n    return a + b;\n  }\n  \n  export function subtract(a: number, b: number): number {\n    return a - b;\n  }\n  \n  namespace Constants {\n    export const PI = 3.14159;\n  }\n}\n\n// 使用命名空间\nconst result = MathUtilities.add(5, 3);\nconsole.log(MathUtilities.Constants.PI);\n\n// 模块示例（单独文件 math.ts）\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  if (b === 0) {\n    throw new Error('除数不能为零');\n  }\n  return a / b;\n}\n\n// 使用模块\nimport { multiply, divide } from './math';\nconst product = multiply(4, 5);\nconst quotient = divide(10, 2);",
    "difficulty": "高级"
  }
]