[
  {
    "title": "什么是React？它的主要特点是什么？",
    "category": "React基础",
    "content": "请解释React的核心概念及其主要特点。",
    "answer": "React是由Facebook开发的一个用于构建用户界面的JavaScript库，它采用组件化的开发方式，使开发者能够更高效地构建和维护复杂的用户界面。\n\n**React的主要特点：**\n\n1. **声明式UI**：React使用声明式语法，让开发者描述UI应该是什么样子，而不是如何实现，使代码更易于理解和调试。\n\n2. **组件化**：React将UI拆分为独立、可复用的组件，每个组件负责自己的逻辑和渲染，便于团队协作和代码维护。\n\n3. **Virtual DOM**：React使用虚拟DOM来提高渲染性能，通过对比前后虚拟DOM的差异，最小化实际DOM操作，提升应用性能。\n\n4. **单向数据流**：React采用自上而下的单向数据流，数据从父组件通过props传递给子组件，使数据流向更清晰，便于追踪和调试。\n\n5. **JSX语法**：JSX是React的语法扩展，允许在JavaScript中编写类似HTML的代码，使组件的结构和逻辑更加紧密地结合。\n\n6. **跨平台**：基于React可以开发Web应用（React）、移动应用（React Native）和桌面应用（React Native for Desktop）等。\n\n7. **丰富的生态系统**：React拥有庞大的社区和丰富的第三方库，如Redux、React Router等，可以帮助开发者解决各种复杂问题。\n\nReact特别适合构建大型、复杂且交互频繁的单页应用（SPA），其组件化和声明式的特性使开发过程更加高效和可维护。",
    "code": "// 一个简单的React组件示例\nimport React from 'react';\n\n// 函数组件\nfunction Greeting(props) {\n  return <h1>Hello, {props.name}!</h1>;\n}\n\n// 使用类组件\nclass Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n\n// 使用JSX语法\nconst element = (\n  <div>\n    <Greeting name=\"React\" />\n    <Counter />\n  </div>\n);\n\n// 在DOM中渲染React元素\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n",
    "difficulty": "初级"
  },
  {
    "title": "什么是React组件？函数组件和类组件有什么区别？",
    "category": "组件",
    "content": "请解释React组件的概念，并比较函数组件和类组件的异同。",
    "answer": "React组件是构建React应用的基本单元，它是一个接收props并返回React元素的函数或类。组件可以被组合在一起，形成复杂的用户界面。\n\n**函数组件（Functional Components）：**\n函数组件是简单的JavaScript函数，接收props作为参数并返回React元素。\n\n**类组件（Class Components）：**\n类组件是继承自React.Component的JavaScript类，必须实现render方法来返回React元素。\n\n**函数组件和类组件的区别：**\n\n1. **语法差异**：\n   - 函数组件是简单的函数\n   - 类组件需要继承React.Component并实现render方法\n\n2. **状态管理**：\n   - 传统的函数组件（React 16.8之前）不能拥有自己的状态\n   - 类组件可以通过this.state和this.setState管理状态\n   - 自React 16.8引入Hooks后，函数组件也可以使用useState等Hook管理状态\n\n3. **生命周期方法**：\n   - 函数组件（没有Hooks时）不能使用生命周期方法\n   - 类组件可以使用生命周期方法如componentDidMount、componentDidUpdate等\n   - 使用Hooks后，函数组件可以通过useEffect模拟生命周期行为\n\n4. **性能**：\n   - 函数组件通常比类组件更轻量，性能更好\n   - 函数组件不需要创建实例，避免了类实例化的开销\n\n5. **代码可读性**：\n   - 函数组件的代码通常更简洁、更易于理解\n   - 类组件的代码结构相对复杂\n\n**最佳实践：**\n\n- 对于简单的UI组件，优先使用函数组件\n- 对于需要管理复杂状态或使用生命周期方法的组件，可以根据个人偏好选择类组件或使用Hooks的函数组件\n- 自React 16.8引入Hooks后，函数组件的功能已经非常强大，推荐在新项目中优先使用函数组件\n随着React的发展，函数组件配合Hooks已经成为React开发的主流方式，提供了更简洁的语法和更强大的功能。",
    "code": "// 函数组件示例\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}!</h1>;\n}\n\n// 使用Hooks的函数组件\nimport React, { useState, useEffect } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  // 模拟componentDidMount和componentDidUpdate\n  useEffect(() => {\n    document.title = \"You clicked \" + count + \" times\";\n  }, [count]); // 仅在count变化时执行\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n\n// 类组件示例\nclass ClassCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  // 生命周期方法\n  componentDidMount() {\n    document.title = \"You clicked \" + this.state.count + \" times\";\n  }\n\n  componentDidUpdate() {\n    document.title = \"You clicked \" + this.state.count + \" times\";\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n}\n",
    "difficulty": "初级"
  },
  {
    "title": "React中的状态管理方式有哪些？",
    "category": "状态管理",
    "content": "请列举并简要说明React应用中常见的状态管理方式。",
    "answer": "在React应用中，状态管理是一个重要的概念，用于管理组件内部的状态以及组件之间的共享状态。以下是React中常见的状态管理方式：\n\n1. **组件内部状态（Component State）**\n   - 使用React的useState Hook（函数组件）或this.state（类组件）管理组件内部的状态\n   - 适用于组件私有的、不需要在多个组件间共享的状态\n\n2. **Props向下传递**\n   - 通过props将状态从父组件传递给子组件\n   - 适用于简单的父子组件间数据传递\n\n3. **Context API**\n   - React官方提供的跨组件状态共享解决方案\n   - 使用createContext、Provider和Consumer（或useContext Hook）实现状态共享\n   - 适用于多个组件间共享简单状态的场景\n\n4. **Redux**\n   - 一个流行的状态管理库，基于Flux架构\n   - 使用单一的store存储应用状态，通过actions和reducers更新状态\n   - 适用于大型应用、复杂状态管理场景\n\n5. **Redux Toolkit**\n   - Redux的官方工具集，简化Redux的使用\n   - 提供了createSlice、configureStore等API，减少样板代码\n   - 推荐在新项目中使用Redux时优先考虑\n\n6. **MobX**\n   - 另一个流行的状态管理库，基于响应式编程\n   - 使用observable、computed和action等概念管理状态\n   - 适用于喜欢响应式编程风格的开发者\n\n7. **Zustand**\n   - 一个轻量级的状态管理库\n   - 使用hooks的方式访问和更新状态\n   - 适用于中小型应用，追求简单和性能的场景\n\n8. **Recoil**\n   - Facebook开发的实验性状态管理库\n   - 基于atom和selector的概念\n   - 适用于需要细粒度状态共享和派生状态的场景\n\n选择状态管理方案时，应考虑应用的规模、复杂度、团队熟悉度等因素。对于简单的应用，使用组件内部状态和Context API可能就足够了；对于复杂的大型应用，可能需要使用Redux、MobX等更强大的状态管理库。",
    "code": "// 1. 组件内部状态（使用useState Hook）\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\n// 2. 使用Context API共享状态\nimport React, { createContext, useContext, useState } from 'react';\n\n// 创建Context\nconst ThemeContext = createContext();\n\n// 创建Provider组件\nexport function ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');\n  };\n\n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// 自定义Hook，方便使用Context\nexport function useTheme() {\n  return useContext(ThemeContext);\n}\n\n// 在组件中使用Context\nfunction ThemedComponent() {\n  const { theme, toggleTheme } = useTheme();\n  \n  return (\n    <div style={{ backgroundColor: theme === 'light' ? '#fff' : '#333', color: theme === 'light' ? '#333' : '#fff' }}>\n      <p>Current theme: {theme}</p>\n      <button onClick={toggleTheme}>Toggle Theme</button>\n    </div>\n  );\n}\n\n// 3. 使用Redux Toolkit管理状态\nimport { configureStore, createSlice } from '@reduxjs/toolkit';\n\n// 创建slice\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: {\n    value: 0\n  },\n  reducers: {\n    increment: state => {\n      state.value += 1\n    },\n    decrement: state => {\n      state.value -= 1\n    },\n    incrementByAmount: (state, action) => {\n      state.value += action.payload\n    }\n  }\n});\n\n// 导出actions\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\n// 配置store\nexport const store = configureStore({\n  reducer: {\n    counter: counterSlice.reducer\n  }\n});\n\n// 在组件中使用Redux\nimport { useSelector, useDispatch } from 'react-redux';\n\nfunction ReduxCounter() {\n  const count = useSelector(state => state.counter.value);\n  const dispatch = useDispatch();\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => dispatch(increment())}>Increment</button>\n      <button onClick={() => dispatch(decrement())}>Decrement</button>\n      <button onClick={() => dispatch(incrementByAmount(5))}>Increment by 5</button>\n    </div>\n  );\n}\n",
    "difficulty": "中级"
  },
  {
    "title": "什么是React Hooks？常用的Hooks有哪些？",
    "category": "React Hooks",
    "content": "请解释React Hooks的概念，并列举常用的Hooks及其用途。",
    "answer": "React Hooks是React 16.8引入的新特性，它允许你在不编写类的情况下使用状态和其他React特性。Hooks让函数组件能够拥有类组件的功能，使代码更简洁、更易于理解和维护。\n\n**常用的React Hooks：**\n\n1. **useState**\n   - 用于在函数组件中添加状态\n   - 接收初始状态作为参数，返回当前状态和更新状态的函数\n   - 适用于管理组件内部的简单状态\n\n2. **useEffect**\n   - 用于处理副作用（如数据获取、订阅、手动DOM操作等）\n   - 接收一个函数和一个依赖数组作为参数\n   - 依赖数组决定了effect何时重新执行\n   - 可以模拟类组件的生命周期方法\n\n3. **useContext**\n   - 用于访问React Context中的值\n   - 接收一个Context对象作为参数，返回该Context的当前值\n   - 适用于跨组件共享状态\n\n4. **useReducer**\n   - useState的替代方案，用于管理复杂的状态逻辑\n   - 接收一个reducer函数和初始状态，返回当前状态和dispatch函数\n   - 适用于状态更新逻辑复杂或需要根据前一个状态计算新状态的场景\n\n5. **useCallback**\n   - 用于缓存函数，避免不必要的重新渲染\n   - 接收一个函数和依赖数组，返回一个记忆化的函数\n   - 适用于将函数传递给子组件，避免子组件不必要的重新渲染\n\n6. **useMemo**\n   - 用于缓存计算结果，避免不必要的重复计算\n   - 接收一个计算函数和依赖数组，返回记忆化的计算结果\n   - 适用于计算开销较大的场景\n\n7. **useRef**\n   - 用于创建一个可变的ref对象，该对象在组件的整个生命周期内保持不变\n   - 可以用来访问DOM元素、存储任意可变值等\n   - 适用于需要在渲染周期之间保存数据的场景\n\n8. **useLayoutEffect**\n   - 与useEffect类似，但它在DOM更新后、浏览器绘制之前同步执行\n   - 适用于需要在浏览器绘制前读取DOM布局并进行操作的场景\n\n9. **useImperativeHandle**\n   - 用于自定义通过ref暴露给父组件的实例值\n   - 通常与forwardRef一起使用\n\n10. **useDebugValue**\n    - 用于在React DevTools中显示自定义Hook的标签\n    - 便于调试自定义Hooks\n\nHooks的出现极大地改善了React的开发体验，使函数组件成为React开发的主流方式。通过合理使用各种Hooks，可以编写出更加简洁、高效、可维护的React代码。",
    "code": "// useState示例\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('React');\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <input\n        type=\"text\"\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n      />\n    </div>\n  );\n}\n\n// useEffect示例\nimport React, { useState, useEffect } from 'react';\n\nfunction DataFetcher() {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    // 模拟数据获取\n    const fetchData = async () => {\n      try {\n        const response = await fetch('https://api.example.com/data');\n        const result = await response.json();\n        setData(result);\n      } catch (error) {\n        console.error('Error fetching data:', error);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n\n    // 清理函数\n    return () => {\n      // 取消订阅、清理定时器等\n    };\n  }, []); // 空依赖数组表示只在组件挂载和卸载时执行\n\n  if (loading) return <div>Loading...</div>;\n\n  return <div>Data: {JSON.stringify(data)}</div>;\n}\n\n// useContext示例\nimport React, { useContext } from 'react';\nimport { ThemeContext } from './ThemeContext';\n\nfunction ThemedButton() {\n  const { theme, toggleTheme } = useContext(ThemeContext);\n\n  return (\n    <button\n      style={{\\n        backgroundColor: theme === 'light' ? '#fff' : '#333',\\n        color: theme === 'light' ? '#333' : '#fff'\\n      }}\n      onClick={toggleTheme}\n    >\n      Toggle Theme\n    </button>\n  );\n}\n\n// useReducer示例\nimport React, { useReducer } from 'react';\n\n// 定义reducer函数\nfunction counterReducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { ...state, count: state.count + 1 };\n    case 'decrement':\n      return { ...state, count: state.count - 1 };\n    case 'reset':\n      return { ...state, count: 0 };\n    case 'incrementBy':\n      return { ...state, count: state.count + action.payload };\n    default:\n      return state;\n  }\n}\n\nfunction ReducerCounter() {\n  const [state, dispatch] = useReducer(counterReducer, { count: 0 });\n\n  return (\n    <div>\n      <p>Count: {state.count}</p>\n      <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>\n      <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>\n      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>\n      <button onClick={() => dispatch({ type: 'incrementBy', payload: 5 })}>Increment by 5</button>\n    </div>\n  );\n}\n\n// useCallback和useMemo示例\nimport React, { useState, useCallback, useMemo } from 'react';\n\nfunction OptimizedComponent() {\n  const [count, setCount] = useState(0);\n  const [todos, setTodos] = useState([{ id: 1, text: 'Learn React' }]);\n\n  // 使用useCallback缓存函数\n  const addTodo = useCallback((text) => {\n    setTodos(prevTodos => [...prevTodos, { id: Date.now(), text }]);\n  }, []); // 空依赖数组表示函数永远不变\n\n  // 使用useMemo缓存计算结果\n  const todoCount = useMemo(() => {\n    console.log('Calculating todo count...');\n    return todos.length;\n  }, [todos]); // 只有当todos变化时才重新计算\n\n  // 计算昂贵的操作\n  const expensiveValue = useMemo(() => {\n    console.log('Computing expensive value...');\n    let result = 0;\n    for (let i = 0; i < 1000000; i++) {\n      result += i;\n    }\n    return result;\n  }, [count]); // 只有当count变化时才重新计算\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <p>Number of todos: {todoCount}</p>\n      <button onClick={() => addTodo(`Todo ${Date.now()}`)}>Add Todo</button>\n      <p>Expensive value: {expensiveValue}</p>\n    </div>\n  );\n}\n",
    "difficulty": "中级"
  }
]